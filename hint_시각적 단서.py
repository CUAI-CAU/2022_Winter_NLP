# -*- coding: utf-8 -*-
"""Level1_chrSegmentation

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-xZV4c93r421GURWUezI_RvjoDRms09o
"""

!pip install jamo

from jamo import j2h
from jamo import j2hcj
import random

"""> class와 method 정의"""

#main class
class letter_segment():
    def __init__(self):
        # 초성 리스트. 19개
        self.chosung_lst = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ',
				'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ']

        # 중성 리스트. 21개
        self.jungsung_lst = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ',
				 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ']

        # 종성 리스트. 28개
        self.jongsung_lst = [' ', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ',
				 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ',
                 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ']
        
        # 이중 모은 제거한 중성 리스트
        self.new_jungsung = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅓ', 'ㅔ', 'ㅗ', 'ㅛ', 'ㅜ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ']

        # 이중 자음 제거한 종성 리스트
        self.new_jongsung = [' ', 'ㄱ', 'ㄴ', 'ㄷ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅇ']

    def segment(self, word_lst):
        seg_lst = []
        for word in word_lst:
            arr = []
            for w in word:
                if '가'<=w<='힣': #ord(word) -> 유니코드 정수를 반환
                    ch1 = (ord(w) - ord('가'))//588
                    ch2 = ((ord(w) - ord('가')) - (588*ch1)) // 28
                    ch3 = (ord(w) - ord('가')) - (588*ch1) - 28*ch2
                    arr.append([self.chosung_lst[ch1], self.jungsung_lst[ch2], self.jongsung_lst[ch3]])
                else:
                    arr.append([w])
            seg_lst.append(arr)
        return seg_lst

    def concat_word(self, word):
        new_word = []
        for words in word:
                if words[2] == ' ':
                    new_word.extend([j2h(words[0], random.choice(self.new_jungsung))])
                    pass
                else:
                    new_word.extend([j2h(words[0], random.choice(self.new_jungsung), random.choice(self.new_jongsung))])
                    pass
        return new_word

    def random_concat(self, seg_lst): 
        #초성은 유지 & 초성, 중성, 종성의 형태도 유지 -> 종성이 없다면 예시에도 없는 형태로
        
        if type(seg_lst[0]) != list:
            raise Exception("parameter should be list type")

        if seg_lst[0][0][0] not in self.chosung_lst:
            raise Exception("parameter should be segmented first")
        
        output = []
        for seg in seg_lst:
            output.append(self.concat_word(seg))
        return output

#(input)w3의 형태: [['소', '개'], ['뜙', '그']]         
def make_word(w3):
    new_lst = []
    for word in w3:
        new_lst.append("".join(word))
    return new_lst

"""> 사용 예시"""

if __name__ == '__main__':
    make_new_word = letter_segment()
    ex_words = ['사과', '레몬']
    seg_lst = make_new_word.segment(ex_words)
    print(seg_lst)
    new_word_lst = make_new_word.random_concat(seg_lst)
    print(f"입력 단어: {ex_words}")
    print(f"나눠진 단어들: {seg_lst}")
    print(f"임의로 생성된 글자(초성 유지): {new_word_lst}")
    print(f"새로 만든 단어 list: {make_word(new_word_lst)}")

